# 二、多线程通信和同步

## (一) 多线程状态

### 1. 线程状态

>- 初始化 ( `Init` ) : 该线程正在被创建
>- 就绪 ( `Ready` ) : 该线程在就绪列表中 , 等待 CPU 调度
>- 运行 ( `Running` ) : 该线程正在运行
>- 阻塞 ( `Blocked` ) : 该线程被阻塞挂起
>   - `Blocked` 状态包括 :  `pend` (锁、 事件、信号量等阻塞)、
>   `suspend`（主动 `pend`）、`delay` (延时阻塞)、 `pendtime` (因为锁、事件、信号量时间等超时等待)
>- 退出 (`Exit`) : 该线程运行结束 , 等待父线程回收其控制块资源
>
><img src="二、多线程通信和同步.assets/image-20230725143410482.png" alt="image-20230725143410482" />

### 2. 竞争状态 (Race Condition) 和 临界区 (Critical Section)

>- 竞争状态 (Race Condition) : 多线程同时读写共享数据
>- 临界区 (Critical Section) : 读写共享数据的代码片段
>- 避免竞争状态策略 , 对临界区进行保护 , 同时只能有一个线程进入临界区

## (二) 互斥体和锁 `mutex`

### 1. 互斥锁`mutex`

>- 不用锁的情况演示
>- 期望输出一整段内容
>- `lock()` 和 `try_lock()`
>- `unlock()`
>
>[实验参考代码](https://github.com/WONGZEONJYU/stu_cpp_thread/tree/main/106thread_mutex)

#### (1) 实验一 : 不加锁的情况

><img src="二、多线程通信和同步.assets/image-20230725143724741.png" alt="image-20230725143724741" />
>
><img src="二、多线程通信和同步.assets/image-20230725143735107.png" alt="image-20230725143735107" />
>
>```tex
>📝资源竞争导致输出混乱
>```

#### (2) 实验二 : 加锁的情况

><img src="二、多线程通信和同步.assets/image-20230725144143901.png" alt="image-20230725144143901" />
>
><img src="二、多线程通信和同步.assets/image-20230725144149799.png" alt="image-20230725144149799" />

#### (3) 实验三 : 不阻塞尝试获取锁

><img src="二、多线程通信和同步.assets/image-20230725144608251.png" alt="image-20230725144608251" />
>
><img src="二、多线程通信和同步.assets/image-20230725144842486.png" alt="image-20230725144842486" />
>
><img src="二、多线程通信和同步.assets/image-20230725144851355.png" alt="image-20230725144851355" />

### 2. 互斥锁的坑 : 线程抢占不到资源

><img src="二、多线程通信和同步.assets/image-20230725144918844.png" alt="image-20230725144918844" />
>
><img src="二、多线程通信和同步.assets/image-20230725145059452.png" alt="image-20230725145059452" />
>
>```
>⚠️补充: 锁有可能会被别的线程获取到,但是由于线程无法预测,所以当前结果没显示到,并不代表不会被别的线程获取到。在上面的结果显示,临界资源被2号线程占用着。
>```

### 3.互斥锁的坑的解决办法 (并非唯一)

><img src="二、多线程通信和同步.assets/image-20230725145454739.png" alt="image-20230725145454739" />
>
><img src="二、多线程通信和同步.assets/image-20230725150401673.png" alt="image-20230725150401673" />

### 4. 超时锁应用 `timed_mutex` ( 避免长时间死锁 )

>可以记录锁获取情况 , 多次超时 , 可以记录日志 , 获取错误情况
>
><img src="二、多线程通信和同步.assets/image-20230725150825686.png" alt="image-20230725150825686" />
>
><img src="二、多线程通信和同步.assets/image-20230725150835741.png" alt="image-20230725150835741" />

### 5. 递归锁(可重入) `recursive_mutex` 和 `recursive_timed_mutex` 用于业务组合

>- 同一个线程中的同一把锁可以锁多次 , 避免了一些不必要的死锁
>- 组合业务用到同一个锁

#### (1) 实验一 : 使用递归锁

><img src="二、多线程通信和同步.assets/image-20230725151100909.png" alt="image-20230725151100909" />
>
><img src="二、多线程通信和同步.assets/image-20230725151108474.png" alt="image-20230725151108474" />

#### (2) 实验二 : 使用普通锁 , $\color{red}{程序直接宕掉}$

><img src="二、多线程通信和同步.assets/image-20230725151430882.png" alt="image-20230725151430882" />
>
><img src="二、多线程通信和同步.assets/image-20230725151436838.png" alt="image-20230725151436838" />
>
>```tex
>📖在工程项目中难免会出现调用多次锁,如果使用普通锁,又没有进行特殊处理的话,程序直接宕掉,在c++11以上版本提供了递归锁,不需要程序员自己去进行特殊处理
>```

### 6. 共享锁 `shared_mutex`

>- c++14 共享超时互斥锁 `shared_timed_mutex`
>- c++17 共享互斥 `shared_mutex`
>- 如果只有写时需要互斥 , 读取时不需要 , 用普通的锁的话如何做?
>- 按照如下代码 , 读取只能有一个线程进入 , 在很多业务场景中 , 没有充分利用 cpu 资源
>
><img src="二、多线程通信和同步.assets/image-20230725151946275.png" alt="image-20230725151946275" />
>
>```
>📖lock_shared()又称读锁
>lock()又称写锁
>
>lock_shared()可以被多个线程获取到锁
>lock()只能被一个线程获取到锁,其他线程调用lock()会被阻塞
>
>lock_shared()获取到锁之后,所有线程的lock()被阻塞
>lock()获取到锁之后,所有线程的lock_shared()和lock()都会被阻塞
>
>```
>
>[shared_mutex共享锁参考代码](https://github.com/WONGZEONJYU/stu_cpp_thread/tree/main/107thread_shared)
>
><img src="二、多线程通信和同步.assets/image-20230725153516211.png" alt="image-20230725153516211" />
>
><img src="二、多线程通信和同步.assets/image-20230725153524515.png" alt="image-20230725153524515" />

## (三) 利用栈特性自动释放锁RAII

### 1. 什么是RAII , 手动代码实现

>RAII（Resource Acquisition Is Initialization）c++之父Bjarne Stroustrup提出;
>使用局部对象来管理资源的技术称为资源获取即初始化；它的生命周期是由操作系统来管理的，
>无需人工介入； 资源的销毁容易忘记，造成死锁或内存泄漏。
>
>[RAII实验参考代码](https://github.com/WONGZEONJYU/stu_cpp_thread/tree/main/108thread_RAII)

#### (1) 实验一 : 手动实现 RAII 管理 mutex 资源

><img src="二、多线程通信和同步.assets/image-20230725154715041.png" alt="image-20230725154715041" />
>
><img src="二、多线程通信和同步.assets/image-20230725154755052.png" alt="image-20230725154755052" />

### 2. c++11支持的RAII管理互斥资源 `lock_guard`

>- C++11 实现严格基于作用域的互斥体所有权包装器
>- `adopt_lock` C++11 类型为 `adopt_lock_t` , 假设调用方已拥有互斥的所有权
>- 通过 `{ }` 控制锁的临界区

#### (1) 实验一 : 

><img src="二、多线程通信和同步.assets/image-20230725155039892.png" alt="image-20230725155039892" />
>
><img src="二、多线程通信和同步.assets/image-20230725155054768.png" alt="image-20230725155054768" />

#### (2) 实验二 : 同一个线程锁两次 , 程序抛出异常

><img src="二、多线程通信和同步.assets/image-20230725155223611.png" alt="image-20230725155223611" />
>
><img src="二、多线程通信和同步.assets/image-20230725155227008.png" alt="image-20230725155227008" />

#### (3) 实验三 : 正常情况 (程序不会被锁两次)

><img src="二、多线程通信和同步.assets/image-20230725155328878.png" alt="image-20230725155328878" />
>
><img src="二、多线程通信和同步.assets/image-20230725155334903.png" alt="image-20230725155334903" />

### 3. c++11引入`unique_lock` 

>- `unique_lock` C++11 实现 **$\color{red}{可移动}$** 的互斥体所有权包装器
>- 支持 **$\color{red}{临时释放锁}$** `unlock()`
>- 支持 `std::adopt_lock` **$\color{red}{(已经拥有锁 , 不加锁 , 出栈区会释放)}$**
>- 支持 `std::defer_lock` **$\color{red}{(延后拥有 , 不加锁 , 出栈区不释放)}$**
>- 支持 `std::try_to_lock` 尝试获得互斥的所有权而 **$\color{red}{不阻塞}$**  , 获取失败退出栈区不会释放 , 通过 `owns_lock()` 函数判断
>- 支持超时参数 , 超时不拥有锁
>
>```c++
>/*unique_lock部分源码*/
>
> unique_lock(unique_lock&& _Other) noexcept : _Pmtx(_Other._Pmtx), _Owns(_Other._Owns) {
>        _Other._Pmtx = nullptr;
>        _Other._Owns = false;
>    }
>
>unique_lock& operator=(unique_lock&& _Other) noexcept /* strengthened */ {
>        if (this != _STD addressof(_Other)) {
>            if (_Owns) {
>                _Pmtx->unlock();
>            }
>
>            _Pmtx        = _Other._Pmtx;
>            _Owns        = _Other._Owns;
>            _Other._Pmtx = nullptr;
>            _Other._Owns = false;
>        }
>        return *this;
>    }
>
>~unique_lock() noexcept {
>        if (_Owns) {
>            _Pmtx->unlock();
>        }
>    }
>
>unique_lock(const unique_lock&)            = delete;
>unique_lock& operator=(const unique_lock&) = delete;
>```
>
>[RAII_unique_lock参考代码](https://github.com/WONGZEONJYU/stu_cpp_thread/tree/main/108thread_RAII)
>
><img src="二、多线程通信和同步.assets/image-20230725160238700.png" alt="image-20230725160238700" />

### 4. C++14引入`shared_lock` 

>- `shared_lock` C++14 实现 **$\color{red}{可移动}$** 的 **$\color{SkyBlue}{共享互斥体}$** 所有权封装器
>- 与`unique_lock` 有着相似功能
>
><img src="二、多线程通信和同步.assets/image-20230725160641971.png" alt="image-20230725160641971" />

### 5. C++17引入`scoped_lock` 

>`scoped_lock` C++17 用于多个互斥体的免死锁 RAII 封装器 类似 `lock()`
>
>[lock()介绍与使用方法](https://en.cppreference.com/w/cpp/thread/lock)

#### (1) 实验一 : 演示死锁

><img src="二、多线程通信和同步.assets/image-20230725162001393.png" alt="image-20230725162001393" />
>
><img src="二、多线程通信和同步.assets/image-20230725162008172.png" alt="image-20230725162008172" />

#### (2) 实验二 : 如何防止死锁

><img src="二、多线程通信和同步.assets/image-20230725162033662.png" alt="image-20230725162033662" />
>
><img src="二、多线程通信和同步.assets/image-20230725162630319.png" alt="image-20230725162630319" />

6.综合案例一 : 使用互斥锁 ( `mutex` ) + ( `list` )模拟线程通信

>- 封装线程基类 `XThread` 控制线程启动和停止
>- 模拟消息服务器线程 接收字符串消息，并模拟处理
>- 通过 `unique_lock` 和 `mutex` 互斥访问 `list<string>` 消息队列
>- 主线程定时发送消息给子线程
>
>[案例一参考代码](https://github.com/WONGZEONJYU/stu_cpp_thread/tree/main/109thread_msg_server)
>
><img src="二、多线程通信和同步.assets/image-20230725163440584.png" alt="image-20230725163440584" />
>
><img src="二、多线程通信和同步.assets/image-20230725163502440.png" alt="image-20230725163502440" />

