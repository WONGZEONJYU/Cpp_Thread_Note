# 二、多线程通信和同步

## (一) 多线程状态

### 1. 线程状态

>- 初始化 ( `Init` ) : 该线程正在被创建
>- 就绪 ( `Ready` ) : 该线程在就绪列表中 , 等待 CPU 调度
>- 运行 ( `Running` ) : 该线程正在运行
>- 阻塞 ( `Blocked` ) : 该线程被阻塞挂起
>   - `Blocked` 状态包括 :  `pend` (锁、 事件、信号量等阻塞)、
>   `suspend`（主动 `pend`）、`delay` (延时阻塞)、 `pendtime` (因为锁、事件、信号量时间等超时等待)
>- 退出 (`Exit`) : 该线程运行结束 , 等待父线程回收其控制块资源
>
><img src="二、多线程通信和同步.assets/image-20230725143410482.png" alt="image-20230725143410482" />

### 2. 竞争状态 (Race Condition) 和 临界区 (Critical Section)

>- 竞争状态 (Race Condition) : 多线程同时读写共享数据
>- 临界区 (Critical Section) : 读写共享数据的代码片段
>- 避免竞争状态策略 , 对临界区进行保护 , 同时只能有一个线程进入临界区

## (二) 互斥体和锁 `mutex`

### 1. 互斥锁`mutex`

>- 不用锁的情况演示
>- 期望输出一整段内容
>- `lock()` 和 `try_lock()`
>- `unlock()`
>
>[实验参考代码](https://github.com/WONGZEONJYU/stu_cpp_thread/tree/main/106thread_mutex)

#### (1) 实验一 : 不加锁的情况

><img src="二、多线程通信和同步.assets/image-20230725143724741.png" alt="image-20230725143724741" />
>
><img src="二、多线程通信和同步.assets/image-20230725143735107.png" alt="image-20230725143735107" />
>
>```tex
>📝资源竞争导致输出混乱
>```

#### (2) 实验二 : 加锁的情况

><img src="二、多线程通信和同步.assets/image-20230725144143901.png" alt="image-20230725144143901" />
>
><img src="二、多线程通信和同步.assets/image-20230725144149799.png" alt="image-20230725144149799" />

